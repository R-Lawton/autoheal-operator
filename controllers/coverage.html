
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>controllers: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/bf2fc6cc711aee1a0c2a/autoheal-operator/controllers/autoheal_controller.go (0.0%)</option>
				
				<option value="file1">github.com/bf2fc6cc711aee1a0c2a/autoheal-operator/controllers/autohealconfig_controller.go (21.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright 2022.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"

        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/log"

        autohealv1alpha1 "github.com/bf2fc6cc711aee1a0c2a/autoheal-operator/api/v1alpha1"
)

// AutohealReconciler reconciles a Autoheal object
type AutohealReconciler struct {
        client.Client
        Scheme *runtime.Scheme
}

//+kubebuilder:rbac:groups=autoheal.redhat.com,resources=autoheals,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=autoheal.redhat.com,resources=autoheals/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=autoheal.redhat.com,resources=autoheals/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the Autoheal object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.12.1/pkg/reconcile
func (r *AutohealReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        _ = log.FromContext(ctx)

        // TODO(user): your logic here

        return ctrl.Result{}, nil
}</span>

// SetupWithManager sets up the controller with the Manager.
func (r *AutohealReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;autohealv1alpha1.Autoheal{}).
                Complete(r)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controllers

import (
        "context"
        "fmt"
        "io/ioutil"
        "net/http"
        "net/url"
        "strings"
        "time"

        "k8s.io/apimachinery/pkg/labels"
        "k8s.io/apimachinery/pkg/runtime"
        "k8s.io/apimachinery/pkg/util/yaml"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"

        "github.com/bf2fc6cc711aee1a0c2a/autoheal-operator/api/v1alpha1"
        log "github.com/sirupsen/logrus"
        core "k8s.io/api/core/v1"
        apierrors "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        ctrl "sigs.k8s.io/controller-runtime"
)

// AutohealConfigReconciler reconciles a AutohealConfig object
type AutohealConfigReconciler struct {
        client.Client
        Scheme     *runtime.Scheme
        httpClient http.Client
}

const (
        RequeueDelaySuccess     = 1 * time.Minute
        RequeueDelayError       = 30 * time.Second
        AutohealConfigSecret    = "autoheal-config"
        AutohealConfigfinalizer = "autoheal-deletion"
)

//+kubebuilder:rbac:groups=autoheal.redhat.com,resources=autohealconfigs,verbs=get;list;watch;create;update;patch;delete
//+kubebuilder:rbac:groups=autoheal.redhat.com,resources=autohealconfigs/status,verbs=get;update;patch
//+kubebuilder:rbac:groups=autoheal.redhat.com,resources=autohealconfigs/finalizers,verbs=update

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
// TODO(user): Modify the Reconcile function to compare the state specified by
// the AutohealConfig object against the actual cluster state, and then
// perform operations to make the cluster state reflect the state specified by
// the user.
//
// For more details, check Reconcile and its Result here:
// - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.12.1/pkg/reconcile
func (r *AutohealConfigReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov0" title="0">{
        autoheal := &amp;v1alpha1.AutohealConfig{}
        err := r.Client.Get(ctx, req.NamespacedName, autoheal)
        if err != nil </span><span class="cov0" title="0">{
                if apierrors.IsNotFound(err) </span><span class="cov0" title="0">{
                        log.Infof("Autoheal CR not found%s", err)
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Errorf("Error getting Autoheal CR %s", err)
                return ctrl.Result{}, err</span>
        }

        <span class="cov0" title="0">if autoheal.DeletionTimestamp == nil &amp;&amp; autoheal.Finalizers == nil </span><span class="cov0" title="0">{
                autoheal.Finalizers = append(autoheal.Finalizers, AutohealConfigfinalizer)
                err = r.Update(ctx, autoheal)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Unable to add finalizer %s", err)
                        return ctrl.Result{}, err
                }</span>
        }

        <span class="cov0" title="0">if autoheal.DeletionTimestamp == nil </span><span class="cov0" title="0">{
                if autoheal.Status.LastSyncPeriod != 0 </span><span class="cov0" title="0">{
                        lastSync := time.Unix(autoheal.Status.LastSyncPeriod, 0)
                        period, err := time.ParseDuration(autoheal.Spec.SyncPeriod)
                        if autoheal.Spec.SyncPeriod == "" </span><span class="cov0" title="0">{
                                log.Info("Please specify a sync period")
                        }</span>
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Error parsing operator resync period %s", err)
                                return ctrl.Result{}, err

                        }</span>
                        <span class="cov0" title="0">nextSync := lastSync.Add(period)
                        if time.Now().Before(nextSync) </span><span class="cov0" title="0">{
                                return ctrl.Result{
                                        Requeue:      true,
                                        RequeueAfter: RequeueDelaySuccess,
                                }, nil

                        }</span>
                }
                <span class="cov0" title="0">configRepo, err := r.getConfigRepoSecret(ctx, autoheal, &amp;autoheal.Status)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Unable to reconcile getting config repo secret %s", err)
                }</span>

                <span class="cov0" title="0">if configRepo != nil </span><span class="cov0" title="0">{
                        files, err := r.readFiles(configRepo)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Unable to get file endpoints from config repo %s", err)
                        }</span>
                        <span class="cov0" title="0">scenarios, err := r.getScenarios(files, configRepo, autoheal)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Unable to get scenerios from config repo %s", err)

                        }</span>
                        <span class="cov0" title="0">err = r.createConfigMaps(autoheal, scenarios, ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Unable to create configmaps %s", err)
                        }</span>
                        <span class="cov0" title="0">err = r.removeUnwantedConfigmap(ctx, &amp;scenarios)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Error("Unable to delete unwanted configmaps")
                        }</span>
                }

        } else<span class="cov0" title="0"> {
                err = r.deleteConfigmap(autoheal, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Unable to reconcile deleting config maps %s", err)
                }</span>

                <span class="cov0" title="0">err = r.deleteConfigSecret(autoheal, ctx)
                if err != nil </span><span class="cov0" title="0">{
                        log.Errorf("Unable to reconcile deleting config secret %s", err)
                }</span>
                <span class="cov0" title="0">if autoheal.Finalizers != nil </span><span class="cov0" title="0">{
                        autoheal.Finalizers = []string{}
                        err = r.Update(ctx, autoheal)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Errorf("Unable to update finalizer to remove it %s", err)
                                return ctrl.Result{}, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return r.updateStatus(autoheal)</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *AutohealConfigReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov0" title="0">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;v1alpha1.AutohealConfig{}).
                Complete(r)
}</span>

// GetConfigRepoSecret Gets the secret needed to provide credentials to sycn with github repo
func (r *AutohealConfigReconciler) getConfigRepoSecret(ctx context.Context, autoheal *v1alpha1.AutohealConfig, status *v1alpha1.AutohealConfigStatus) (*v1alpha1.ConfigRepositoryInfo, error) <span class="cov10" title="4">{
        log.Info("Stage: Reading config secret")
        configRepoSecret := &amp;core.Secret{}
        // secretSelector := &amp;client.ObjectKey{
        //         Namespace: "autoheal-operator",
        //         Name:      AutohealConfigSecret,
        // }

        err := r.Client.Get(ctx, client.ObjectKey{Name: autoheal.Spec.SecretName, Namespace: autoheal.Namespace}, configRepoSecret)
        if err != nil </span><span class="cov1" title="1">{
                if apierrors.IsNotFound(err) </span><span class="cov1" title="1">{
                        log.Info(err)
                        return nil, nil
                }</span>
                <span class="cov0" title="0">log.Errorf("Can't get config repo secret %s", err)
                return nil, err</span>
        }

        <span class="cov8" title="3">if configRepoSecret.Name != AutohealConfigSecret </span><span class="cov0" title="0">{
                log.Info("Config secret not found please create the autoheal config secret")
                return nil, nil
        }</span>
        <span class="cov8" title="3">if string(configRepoSecret.Data["repository"]) == "" || string(configRepoSecret.Data["tag"]) == "" || string(configRepoSecret.Data["access_token"]) == "" </span><span class="cov1" title="1">{
                log.Info("Confg secret found but values are empty")
                return nil, nil
        }</span>

        <span class="cov5" title="2">configurl := string(configRepoSecret.Data["repository"])
        _, err = url.ParseRequestURI(configurl)
        if err != nil </span><span class="cov1" title="1">{
                log.Errorf("Unable to parse config URL from secret %s", err)
                return nil, err
        }</span>

        <span class="cov1" title="1">var configRepoInfo v1alpha1.ConfigRepositoryInfo
        configRepoInfo.Tag = string(configRepoSecret.Data["tag"])
        configRepoInfo.RepositoryURL = string(configRepoSecret.Data["repository"])
        configRepoInfo.AccessToken = string(configRepoSecret.Data["access_token"])

        status.LastSyncPeriod = time.Now().Unix()
        return &amp;configRepoInfo, nil</span>
}

// ReadFiles Gets all the filename of the scripts from the repo
func (r *AutohealConfigReconciler) readFiles(repo *v1alpha1.ConfigRepositoryInfo) (*v1alpha1.AutohealConfigTree, error) <span class="cov10" title="4">{
        log.Info("Stage: Parsing file endpoints")
        repoUrl, err := url.ParseRequestURI(fmt.Sprintf("%s/git/trees/%s?recursive=true", repo.RepositoryURL, repo.Tag))
        if err != nil {
                log.Errorf("U</span><span class="cov0" title="0">nable to parse url %s", err)
                return nil, err
        }

</span>        req, err := http.NewRequest(http.MethodGet, repoUrl.String(), nil)
        <span class="cov10" title="4">if err != nil {
                log.Errorf("U</span><span class="cov0" title="0">nable to create new http request%s", err)
                return nil, err
        }
        r</span>eq.Header.Set("Authorization", fmt.Sprintf("token %s", repo.AccessToken))
        <span class="cov10" title="4">req.Header.Set("Accept", "application/vnd.github.v3+json")

        resp, err := r.httpClient.Do(req)
        if err != nil {
                log.Errorf("U</span><span class="cov1" title="1">nable to send http request %s", err)
                return nil, err
        }
        i</span>f resp.StatusCode != http.StatusOK {
        <span class="cov8" title="3">        log.Errorf("Non 200 response back, </span><span class="cov5" title="2">got status code %d error: %s", resp.StatusCode, err)
                return nil, nil
        }

</span>        bytes, err := ioutil.ReadAll(resp.Body)
        <span class="cov1" title="1">if err != nil {
                log.Errorf("U</span><span class="cov0" title="0">nable to read http response body %s", err)
                return nil, err
        }
        e</span>rr = resp.Body.Close()
        <span class="cov1" title="1">if err != nil {
                return nil, e</span><span class="cov0" title="0">rr
        }

</span>        fileName := v1alpha1.AutohealConfigTree{}
        <span class="cov1" title="1">files := v1alpha1.AutohealConfigTree{}
        err = yaml.Unmarshal(bytes, &amp;fileName)
        if err != nil {
                log.Errorf("Unable to parse yaml file endpoints from config repo %s", err)
                return nil, err
        }
</span>
        for _, endpoints := range fileName.Tree {
                </span>if strings.Contains(endpoints.Filename, ".yaml") {
                        files.Tree = append(files.Tree, endpoints)
        <span class="cov1" title="1">        }
</span>
</span>        }

</span>        return &amp;files, nil

}

</span>// getScenarios Retrieves the scenarios scripts from the files gotten from the file names in the above function
func (r *AutohealConfigReconciler) getScenarios(files *v1alpha1.AutohealConfigTree, repo *v1alpha1.ConfigRepositoryInfo, autoheal *v1alpha1.AutohealConfig) ([]v1alpha1.AutohealConfigScenario, error) {
        log.Info("Stage: Retrieving Scenarios from config repo")

        scenario := v1alpha1.AutohealConfigScenario{}
        scenarios := []v1alpha1.AutohealConfigScenario{}

        for _, endpoints := range files.Tree {
                // httpclient := http.Client{}
                repoUrl, err := url.ParseRequestURI(fmt.Sprintf("%s/contents/%s", repo.RepositoryURL, endpoints.Filename))
                if err != nil {
</span>                        return nil, err
                }

</span>                req, err := http.NewRequest(http.MethodGet, repoUrl.String(), nil)
                i</span>f err != nil {
                        log.Errorf("Unable to create new http request")
                <span class="cov0" title="0">        return nil, err

</span>                }
                if repo.Tag != "" {
                        q := req.URL.Query()
                        </span>q.Add("ref", repo.Tag)
                <span class="cov0" title="0">        req.URL.RawQuery </span><span class="cov0" title="0">= q.Encode()
                }
                req.Header.Set("Authorization", fmt.Sprintf("token %s", repo.AccessToken))
                req.Header.Set("Accept", "application/vnd.github.v3.raw")

</span>                <span class="cov0" title="0">resp, err := r.httpClient.Do(req)
                if err != nil {
                        log.Errorf("Unable to send http request")
                        return nil, err

</span>                }
                if resp.StatusCode != http.StatusOK {
                        log.Errorf("Non 200 response back, got status code %d ", resp.StatusCode)
                        </span>return nil, err
                <span class="cov0" title="0">}
</span>
                bytes, err := ioutil.ReadAll(resp.Body)
                i</span>f err != nil {
                        log.Errorf("Unable to read response body %s", err)
                <span class="cov0" title="0">        return nil, err

</span>                }
                err = resp.Body.Close()
                if err != nil {
                        </span>return nil, err
                <span class="cov0" title="0">}

</span>                err = yaml.Unmarshal(bytes, &amp;scenario)
                i</span>f err != nil {
                        log.Errorf("Unable to parse yaml scenarios from config repo %s", err)
                <span class="cov0" title="0">        return nil, err

</span>                }
                scenarios = append(scenarios, scenario)

        }
</span>        r<span class="cov0" title="0">eturn scenarios, nil
</span>}

/<span class="cov0" title="0">/ createConfigMaps Cr</span>eates the config maps based on the scenarios gotten from github
func (r *AutohealConfigReconciler) createConfigMaps(autoheal *v1alpha1.AutohealConfig, scenario []v1alpha1.AutohealConfigScenario, ctx context.Context) error {
        log.Info("Stage: Creating/updating configmaps")

        for _, scenarios := range scenario {
                configmap := core.ConfigMap{
                        ObjectMeta: metav1.ObjectMeta{
                                Name:      scenarios.Name,
</span>                                Namespace: autoheal.Namespace,
                        },
                }

                _, err := controllerutil.CreateOrUpdate(ctx, r.Client, &amp;configmap, func() error {
                        if configmap.Data == nil {
                                configmap.Data = make(map[string]string)
                        }
</span>                        configmap.Labels = map[st</span><span class="cov0" title="0">ring]string{
                                "app": "autoheal",
                        }</span>
                        <span class="cov0" title="0">configmap.Data["query"] = scenarios.Query
                        configmap.Data["label"] = scenarios.Label
                        configmap.Data["script"] = scenarios.Script
                        configmap.Data["gracePeriod"] = scenarios.GracePeriod
                        return nil

                })
                if err != n</span>il {
                        log.Errorf("Unable to create configmap")
                        return err

</span>                }
        }
        return nil
}
</span>
/<span class="cov0" title="0">/ updateSt</span>atus Updates the controller to how long until next requeue of the reconciller depening on if its a error or not
func (r *AutohealConfigReconciler) updateStatus(autoheal *v1alpha1.AutohealConfig) (ctrl.Result, error) {
        err := r.Client.Status().Update(context.Background(), autoheal)
        if err != nil {
                return ctrl.Result{
                        Requeue:      true,
                        RequeueAfter</span><span class="cov0" title="0">: RequeueDelayError,
                }, err
        }

        return ctrl.Result{
                </span>Requeue:      true,
                RequeueAfter: RequeueDelaySuccess,
        <span class="cov0" title="0">}, nil
}

// dele</span>teConfigSecret Delests the config secret with creds to sync to the repo
func (r *AutohealConfigReconciler) deleteConfigSecret(autoheal *v1alpha1.AutohealConfig, ctx context.Context) error {
        configRepoSecret := &amp;core.Secret{}
        secretSelector := &amp;client.ObjectKey{
                Namespace: autoheal.Namespace,
                Name:      AutohealConfigSecret,
        }
        err := r.Client.Get(ctx, *secretSelector, configRepoSecret)
        if err != nil {
                if apierrors.IsNotFound(err) {
                        log.Info("Unable to find config secret")

</span>                }
</span>                log.Errorf("Error cant get config secret")
                return err

</span>        }<span class="cov0" title="0">
        log.Info("S</span>tage Clean up: Deleting config repo secret")
        err = r.Client.Delete(ctx, configRepoSecret)
        if err != nil {
        <span class="cov0" title="0">        if apierrors.IsNotFound(err) {
                        log.Info("Unable to find config secret")
                        return nil
</span>
</span>                }
                log.Errorf("Error getting secret for deletion")
                return err
        }
</span>
        return nil
</span>}

/<span class="cov0" title="0">/ deleteCo</span>nfigmap Deletes all configs for cleanup
func (r *AutohealConfigReconciler) deleteConfigmap(autoheal *v1alpha1.AutohealConfig, ctx context.Context) error {
        configmap := &amp;core.ConfigMapList{}
        configSelector := &amp;client.ListOptions{
                LabelSelector: labels.SelectorFromSet(map[string]string{
                        "app": "autoheal",
                }),
                Namespace: autoheal.Namespace,
        }

        err := r.Client.List(ctx, configmap, configSelector)
        if err != nil {
                log.Errorf("Failed to get list of configmaps")
                return err
        }
</span>        log.Info("Stage Clean up: Deleting configmap")
        for _, configs := range configmap.Items {
                </span>err = r.Client.Delete(ctx, &amp;configs)
        <span class="cov0" title="0">        if err != nil {
                        if apierrors.IsNotFound(err) {
</span>                                log.Info("Cannot find configmap:", configs)

</span>                        }
</span>                        log.Errorf("Error cannnot delete configmap")
                        return err
                }
</span>        }

</span>        return nil
}

/<span class="cov0" title="0">/ removeUn</span>wantedConfigmap Deletes unwanted config maps i.e if the config repo has been changed to remove a scenerio it is removed from the cluster
func (r *AutohealConfigReconciler) removeUnwantedConfigmap(ctx context.Context, scenarios *[]v1alpha1.AutohealConfigScenario) error {
        configmap := &amp;core.ConfigMapList{}
        configSelector := &amp;client.ListOptions{
                LabelSelector: labels.SelectorFromSet(map[string]string{
                        "app": "autoheal",
                }),
        }

        err := r.Client.List(ctx, configmap, configSelector)
        if err != nil {
                log.Errorf("Error cant get configmap %s", err)
                return err
        }
</span>        isRequested := func(name string) bool {
                for _, files := range *scenarios {

</span>        <span class="cov0" title="0">                if name == files.Name {
</span>                                return true
</span>                        }
                }
</span>                return false
        }
</span>
        f<span class="cov0" title="0">or _, config</span>s := range configmap.Items {

                if !isRequested(configs.Name) {
        <span class="cov0" title="0">                log.Infof("Deleting unwanted configmap</span><span class="cov0" title="0"> name: %s", configs.Name)
                        err = r.Client.Delete(ctx, &amp;configs)
                        if err != nil {
</span>                                if apierrors.IsNotFound(err) {
                                        log.Info("Cannot find configmap:", configs)

</span>                                }
</span>                        }
                }

</span>        }
        return nil

}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
